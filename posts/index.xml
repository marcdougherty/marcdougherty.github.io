<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Marc Dougherty</title><link>https://www.marcdougherty.com/posts/</link><description>Recent content in Posts on Marc Dougherty</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Â© 2023 Marc Dougherty</copyright><lastBuildDate>Wed, 08 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://www.marcdougherty.com/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Handy Yaml Tricks!</title><link>https://www.marcdougherty.com/posts/yaml-tricks/</link><pubDate>Wed, 08 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.marcdougherty.com/posts/yaml-tricks/</guid><description>(This content was originally published at https://dev.to/muncus/handy-yaml-tricks-415p)
In the past few years, YAML ( http://yaml.org) has become an essential part of software, particularly for infrastructure-as-code tools. Yaml at the heart of kubernetes configuration, kubernetes-inspired APIs like Google&amp;rsquo;s config connector, and a number of workflow systems like Google Cloud Workflows and Github Actions.
In its simplest forms, Yaml is quite human-readable, but over time many of these configurations become more complex, and the documentation of these formats is not always as complete or searchable as we might like.</description></item><item><title>Day 2 Observability - calls to other services</title><link>https://www.marcdougherty.com/posts/o11y-calling-other-services/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.marcdougherty.com/posts/o11y-calling-other-services/</guid><description>This post assumes you&amp;rsquo;re already familiar with OpenTelemetry, and are already collecting some observability data.
Whether you&amp;rsquo;ve chosen automatic instrumentation, or manual, you&amp;rsquo;re now collecting telemetry data from your code. Congratulations ðŸŽ‰
But what about all the other code you&amp;rsquo;re using? When your service makes a database query, or fetches weather data, you&amp;rsquo;re using someone else&amp;rsquo;s code. These other services may have their own production problems - can you separate issues in your code from issues in a dependency with your current observability signals?</description></item><item><title>More Github CLI Tips</title><link>https://www.marcdougherty.com/posts/github-cli/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.marcdougherty.com/posts/github-cli/</guid><description>Last year, I started working in a number of public Github repositories, and learned to use the gh Github CLI. I wrote an article about using the github cli with multiple repos, but given how much my workflow has changed, I think its time for an update.
Picking a random teammate # Sometimes, I need to pick a human to be responsible for something (usually a PR review). When there is no obvious choice (for example, someone who already knows the context of the PR), I caught myself relying on the same team members repeatedly.</description></item><item><title>Understanding GCP's Loadbalancer models</title><link>https://www.marcdougherty.com/posts/loadbalancers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.marcdougherty.com/posts/loadbalancers/</guid><description>I recently spent some time with external application loadbalancers in GCP, and I found the data model pretty difficult to work with. What follows is an attempt to better explain these concepts, practicing some of the advice from Docs for Developers, which I&amp;rsquo;ve been reading.
Overview # External Application Loadbalancers are represented in the API by a series of related configuration objects. There is no single &amp;ldquo;Loadbalancer&amp;rdquo; object, so it is important to ensure the relevant objects all reference each other.</description></item></channel></rss>